#!/bin/bash

#aucun arg accepte
if [ -n "$1" ]; then
	echo "Usage : $0"
	exit 1
fi

# affichage du repertoire / selection du rep a transferer
echo -n "Vous êtes dans : "; pwd; echo "Voici les fichiers présents"; ls --color=auto

# presence du fichier
echo -e -n "\nLe fichier souhaité est-il présent ? [y/n] "; read bool;
if [ -z "$bool" ]; then
	echo -e "\nVous n'avez rien tapé, le programme ne peut continuer"
	exit 1
fi

if [ "$bool" != "n" ] && [ "$bool" != "y" ]; then
	echo -e "\nChoix non valide, arrêt du programme"
	exit 1
fi

# a transforme en une fonction
if [ "$bool" = "n" ]; then
	read -p "Entrez le nom du fichier : " new_file; echo -e "Nous recherchons le répertoire..."
# reduit la recherche a son home : $HOME
	file=`find "$HOME/Documents/" -path "*/$new_file"`
	# !trouve
	if [ -z "$file" ]; then
		echo -e "\nFichier à transférer introuvable ! (Veuillez à respecter les maj,min,symboles,etc.)\nFin du programme"
		exit 1
	fi
	#
	# trouve
	echo -e "\nFichier à transférer : $file";
	#
fi

if [ "$bool" = "y" ]; then
	read -p "Entrez le fichier à transférer : " file

#chemin absolu
file="$HOME/$new_file"
fi

### si égal à file, ok. Sinon autre operation (en fonction de l'action)
for i in `ls`
do
	if [ "$file" = "$i" ]; then
		echo -e "Fichier trouvé !\n"; bool="n" #pour passer a la suite et verifier la mauvaise entree.
	fi
	temp="$i"
done
#mauvaise entree
if [ "$file" != "$temp" ] && [ "$bool" = "y" ]; then
	echo -e "Cette destination n'existe pas, le programme est arrêté."; exit 1
fi

# choix de la destination
bool=""

echo -e "\nVous allez désigner la destination du fichier"

#type de stockage
read -p "La destination est-elle interne ou externe ? [i/e] " type_stock
if [ -z "$type_stock" ]; then
	echo -e "\nDestination vide, le programme ne peut continuer"
	exit 1
fi

if [ "$type_stock" != "i" ] && [ "$type_stock" != "e" ]; then
	echo -e "\nChoix non valide, arrêt du programme"
	exit 1
fi

if [ "$type_stock" = "e" ]; then
# affichage des disques
	echo -e "Rassurez-vous d'avoir connecté le stockage externe !\nVoici les destinations possibles : "; ls --color=auto /media/${USER}
# choix du disque
	read -p "Entrez le nom de la destination : " stock
# on checke si vide
	if [ -z "$stock" ]; then
		echo -e "Destination vide, arrêt du programme."; exit 1
	fi
#
# on checke l'existence du nom tape
	for dest in `ls /media/${USER}` #reflechir a l'implementation de find... peut faire le taf
	do
		if [ "$dest" = "$stock" ]; then
			echo -e "\nDestination correcte, envoi en cours..."
			rsync -arbpu -E $file /media/${USER}/"$stock" --progress 2> erreurs_rsync
			echo -e "\nFin de l'opération."
			exit 1
		fi
		temp=$dest
	done
	#mauvaise entree
	if [ "$stock" != "$temp" ]; then
		echo -e "Cette destination n'existe pas, le programme s'arrête."; exit 1
	fi
#
fi

# la dest est donc interne
echo -e "\nVoici votre répertoire : "; ls --color=auto $HOME

read -p "La destination est-elle présente ? [y/n] " bool
if [ -z "$bool" ]; then
	echo -e "\nVous n'avez rien tapé, le programme ne peut continuer."
	exit 1
fi

if [ "$bool" != "n" ] && [ "$bool" != "y" ]; then
	echo -e "\nChoix non valide, arrêt du programme"
	exit 1
fi


if [ "$bool" = "n" ]; then
# on navigue dans l'arborescence
	while ( "$bool" = "n" )
	do
# pas besoin de ceci
		read -p "Possible destination : " new_stock;
		for dest in `ls`
		do
			if [ "$dest" = "$new_stock" ]; then
				cd ${new_stock}; ls --color=auto; read -p "La destination est-elle présente ? [y/n] " bool
				stock=`find $HOME -path "*/${new_stock}"`
			fi
		done
		echo -e "Pas de correspondance ! "
	done

#
fi

#echo "ok"
if [ "$bool" = "y" ]; then
	read -p "Entrez la destination : " stock;
	for dest in `ls`
	do
		if [ "$dest" = "$stock" ]; then
			echo -e "\nDestination correcte, envoi en cours..."
			rsync -arbpu -E $file "$HOME/$stock" --progress 2> erreurs_rsync
			echo -e "\nFin de l'opération. Arrêt du programme !"
			exit 1
		fi
# cette portion n'est consideree que si non correspondance il y a.
	temp=$dest
	done
fi

# mauvaise frappe
if [ "$temp" != "$stock" ]; then
	echo "Destination incohérente ! Arrêt du programme."; exit 1
fi